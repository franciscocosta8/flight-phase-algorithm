%% Flight Phase Identification Pipeline
% Load results and filter invalid flights
load('results.mat');
%% 
folder    = 'jan25';
fileList  = dir(fullfile(folder,'*.mat'));
Nfiles    = numel(fileList);
%results   = repmat(struct(), 1, Nfiles);  % pré-aloca um array de structs
dailySummaries = cell(1, Nfiles);

%%
tic
for k = 4%:Nfiles

    fn = fullfile(folder, fileList(k).name);
    load(fn); 
    validIdx = arrayfun(@(f) isValidFlight(f.callsign, f.airline,f.acType ,f.departure), results);
    cleanFlights = results(validIdx);
    notcleanFlights = results(~validIdx);
    fprintf("Filtered to %d valid flights.\n", sum(validIdx));
    
    % Stage 2 – Fuzzy Phase Identification per ADS-B Sample
    k
    % voos = input('Insert flight index (ex: 1) or interval to be plot (ex: 1:3): ');
    % 
    % % Valida entrada
    % if isempty(voos)
    %     disp('No selected flight. Program is not going to depict any figure.');
    % end
    
    
    cfg=config();
    N = numel(cleanFlights);
    allStates = cell(1, N);
    
    % Define lineear spaces
    eta = cfg.eta;      % altitude in feet
    tau = cfg.tau;   % rate of climb in ft/min
    v   = cfg.v;        % speed in knots
    p   = cfg.p;          % phase axis (0 to 6)
    
    % Loop over flights
    parfor f=1:N
    %for f=goaround;
        T = cleanFlights(f).flightData;
    
        if all(isnan(T.h_QNH_Metar) ) || all(isnan(T.h_dot_baro)) || all(isnan(T.gs))
            continue
        end
    
        validSamples=isfinite(T.h_dot_baro) & isfinite(T.gs) & isfinite(T.h_QNH_Metar);
    
        if sum(validSamples)<25
           continue
        end
    
        alt   = T.h_QNH_Metar(validSamples);
        roc   = T.h_dot_baro(validSamples);
        gs    = T.gs(validSamples);
        isGnd = T.onGround(validSamples);
        time = T.time(validSamples);
    
        phaseStates = classifyFlightPhase(T, cfg);
        if isempty(phaseStates)
            continue;
        end
        alt=T.h_QNH_Metar (validSamples);
        roc   = T.h_dot_baro (validSamples);
        gs    = T.gs(validSamples);
        isGnd = T.onGround(validSamples); 
        time=T.time;
    
        descentFlags = (phaseStates == FlightPhase.Descent);
        % Identify Go Around
        if any(phaseStates == FlightPhase.Climb) && any(phaseStates == FlightPhase.Descent)
            [phaseStates] = detectGoAround(time, alt, phaseStates, FlightPhase.Climb, descentFlags);
        else
            allStates{f}=phaseStates;
            labels= FlightPhase.list();    
            allStates_names{f} = labels(phaseStates);
        end
    
        phaseStates = filterChangeOfPhase(phaseStates, FlightPhase.Climb, FlightPhase.Descent, FlightPhase.Level);
    
         % remove points classified with climb or descent that are not
         % changing altitude
        [keepIdx,phaseStates] = filterFlatClimbDescent(alt, phaseStates);
        t_removed=time(~keepIdx);
        alt_removed=alt(~keepIdx);
    
        % Agora refazemos todos os vetores “time, roc, alt, gs, phaseStates”
        time = time(keepIdx);
        roc  = roc(keepIdx);
        alt  = alt(keepIdx);
        gs   = gs(keepIdx);
        phaseStates = phaseStates(keepIdx);
    
        allStates{f}=phaseStates;
        labels= FlightPhase.list();     
        allStates_names{f} = labels(phaseStates);
    
        % Decidir fase global de voo
        
        hasGoAround = any(phaseStates == FlightPhase.GoAroundClimb);  
        if hasGoAround
            allOverallPhase(f) = string(FlightOverallPhase.GoAround);
        else
    
            % (b) Caso não haja Go-Around, contamos quantos pontos de cada fase
            nClimb  = sum(phaseStates == FlightPhase.Climb);
            nDes    = sum(phaseStates == FlightPhase.Descent);
            nLevel  = sum(phaseStates == FlightPhase.Level);
    
            altFirst = alt(1);
            altLast = mean( alt( max(end-10,1) : end ) );
    

            if (nDes > nClimb) && (altLast < 2200)
                allOverallPhase(f) = string(FlightOverallPhase.Landing);
    
            elseif (nClimb > nDes) && (altLast > 5000) && (altFirst<3500)
                allOverallPhase(f) = string(FlightOverallPhase.Takeoff);

            elseif  (altFirst > 5000) && (altLast > 5000)
                allOverallPhase(f) = string(FlightOverallPhase.Cruise);
   
            else
                allOverallPhase(f) = string(FlightOverallPhase.NonDetected); 
            end
        end
    

        % % Plot desired flights
        % if ismember(f, voos)
            rawStates = allStates_names{f};     
            rawStates = cellstr(rawStates(:));  

            [grp, grpNames] = findgroups(rawStates);
            cmap = cell2mat(values(cfg.phase2color, grpNames));


            % cria figura e ax1
            hFig = figure('Position',[100 100 1000 500]);
            ax1 = axes('Parent', hFig);
            hold(ax1, 'on');

            %  linha de altitude estimada
            %alt_est = interp1(t, alt, t0, 'pchip');
            %plot(ax1, t0, alt_est, '-', 'LineWidth',1.5, ...
            %     'Color',[0 0 0], 'DisplayName','Estimated altitude');

            %pontos removidos
            %scatter(ax1, t_removed, alt_removed, 36, 'r', 'x', ...
             %      'DisplayName','Removed points');

            %  loop de scatter para cada fase
            for i = 1:numel(grpNames)
                xi = grp == i;
                scatter(ax1, time(xi), alt(xi), 100, ...
                        'Marker', '.', ...
                        'MarkerEdgeColor', cmap(i,:), ...
                        'DisplayName', grpNames{i});
            end

            % 4) ajustes finais
            ylabel(ax1, 'Altitude (ft)');
            ylim(ax1, [min(alt)-500, max(alt)+500]);
            datetick(ax1, 'x', 'HH:MM', 'keepticks');
            xlabel(ax1, 'Time');
            title(ax1, sprintf("Flight %s (idx %d)", cleanFlights(f).callsign, f));
            legend(ax1, 'Location', 'eastoutside');
            grid(ax1, 'on');
        % end
    end
    summaryPhases = summarizePhases(allOverallPhase);
    clear allOverallPhase
    dailySummaries{k} = struct( ...
         'file',    fileList(k).name, ...     % nome do ficheiro (i.e. data)
         'summary', summaryPhases ...         % o que queres manter
     );
        %% –– NOVO: Contagem de voos por companhia aérea e por tipo de avião em cada fase ––
    
    % 1) Extrai, para cada voo, a fase global, a companhia e o tipo de aeronave
    phases_f   = summaryPhases.Phase;       % Coluna 'Phase' de summaryPhases
    airlines_f = { cleanFlights.airline }'; % vetor de strings com as companhias
    aircraft_f = { cleanFlights.acType  }'; % vetor de strings com os tipos de avião

    % 2) Monta tabela para agrupamento
    Tcounts = table(phases_f, airlines_f, aircraft_f, ...
        'VariableNames', {'Phase','Airline','Aircraft'});

    % 3) Conta número de voos por companhia em cada fase
    countsByAirline = varfun(@numel, Tcounts, ...
        'InputVariables','Airline', ...
        'GroupingVariables',{'Phase','Airline'});

    % 4) Conta número de voos por tipo de avião em cada fase
    countsByAircraft = varfun(@numel, Tcounts, ...
        'InputVariables','Aircraft', ...
        'GroupingVariables',{'Phase','Aircraft'});

    % 5) Armazena as tabelas de contagem no struct de resumo diário
    dailySummaries{k}.countsByAirline  = countsByAirline;
    dailySummaries{k}.countsByAircraft = countsByAircraft;

end

disp('Program finished.')
toc